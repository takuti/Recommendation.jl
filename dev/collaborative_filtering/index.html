<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Collaborative Filtering · Recommendation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Recommendation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Recommendation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../notation/">Notation</a></li><li><a class="tocitem" href="../baseline/">Non-Personalized Baselines</a></li><li class="is-active"><a class="tocitem" href>Collaborative Filtering</a><ul class="internal"><li><a class="tocitem" href="#k-Nearest-Neighbor"><span><span>$k$</span>-Nearest Neighbor</span></a></li><li><a class="tocitem" href="#Singular-Value-Decomposition"><span>Singular Value Decomposition</span></a></li><li><a class="tocitem" href="#Matrix-Factorization"><span>Matrix Factorization</span></a></li></ul></li><li><a class="tocitem" href="../factorization_machines/">Factorization Machines</a></li><li><a class="tocitem" href="../content_based_filtering/">Content-Based Filtering</a></li><li><a class="tocitem" href="../evaluation/">Evaluation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">References</a></li><li class="is-active"><a href>Collaborative Filtering</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Collaborative Filtering</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/takuti/Recommendation.jl/blob/master/docs/src/collaborative_filtering.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Collaborative-Filtering"><a class="docs-heading-anchor" href="#Collaborative-Filtering">Collaborative Filtering</a><a id="Collaborative-Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Collaborative-Filtering" title="Permalink"></a></h1><p>Since datasets on conventional recommender systems are commonly represented as a user-item matrix <span>$R \in \mathbb{R}^{|\mathcal{U}| \times |\mathcal{I}|}$</span>, this page specially focuses on the matrix completion techniques for recommendation. A key idea of matrix-completion-based recommendation is to predict missing values in <span>$R$</span> and figure out the most promising items to a target user as follows:</p><p><img src="../assets/images/user-item-matrix.png" alt="user-item-matrix"/></p><p>To give an example, for a user <span>$a$</span>, item <span>$2$</span> and <span>$4$</span> are unobserved. In this case, what a recommender does is to predict the missing elements and decides which item is more likely to be preferred by the user.</p><p>In particular, collaborative filtering (CF) is one of the most popular matrix-completion-based recommenders which was originally introduced by <a href="https://dl.acm.org/citation.cfm?id=138867">Goldberg et al.</a> in 1992. The goal of CF algorithm is to suggest new items for a particular user by modeling user-user and item-item similarities. From a users&#39; perspective, CF assumes that users who behaved similarly on a service share common tastes for items. On the other hand, items which resemble each other are likely to be preferred by the same users.</p><h2 id="k-Nearest-Neighbor"><a class="docs-heading-anchor" href="#k-Nearest-Neighbor"><span>$k$</span>-Nearest Neighbor</a><a id="k-Nearest-Neighbor-1"></a><a class="docs-heading-anchor-permalink" href="#k-Nearest-Neighbor" title="Permalink"></a></h2><p>A <span>$k$</span>-nearest neighbor (<span>$k$</span>-NN) approach, one of the simplest CF algorithms, runs in two-fold. First, missing values in <span>$R$</span> is predicted based on the past observations. Here, a <span>$(u, i)$</span> element between a target user <span>$u$</span> and item <span>$i$</span> is estimated by explicitly computing the similarities of users (items). Second, a recommender chooses top-<span>$k$</span> items from the results of the prediction step.</p><p>Importantly, <span>$k$</span>-NN can be classified into a <em>user-based</em> and <em>item-based</em> algorithm. In a user-based algorithm, user-user similarities are computed for every pairs of rows in <span>$R$</span>. By contrast, item-based CF stands on column-wise similarities between items. Following figure illustrates how <span>$k$</span>-NN works on a user-item matrix <span>$R$</span>:</p><p><img src="../assets/images/cf.png" alt="cf"/></p><p>Note that the figure is inspired by a paper written by <a href="https://dl.acm.org/citation.cfm?id=372071">Sarwar et al.</a></p><p>The elements are ratings in a <span>$[1, 5]$</span> range for each user-item pair, so <span>$1$</span> and <span>$2$</span> mean relatively negative feedback and vice versa. In the figure, user <span>$a$</span> and <span>$c$</span> seem to have similar tastes because both of them gave nearly identical feedback to item <span>$1$</span>, <span>$4$</span> and <span>$6$</span>. From an item-item perspective, item <span>$4$</span> and <span>$6$</span> are similarly rated by user <span>$a$</span>, <span>$b$</span> and <span>$c$</span>.</p><p>In order to measure the similarities between rows (columns), the Pearson correlation and cosine similarity are widely used. For <span>$d$</span>-dimensional vectors <span>$\mathbf{x}, \mathbf{y} \in \mathbb{R}^d$</span>, the Pearson correlation <span>$\mathrm{corr}(\mathbf{x}, \mathbf{y})$</span> and cosine similarity <span>$\mathrm{cos}(\mathbf{x}, \mathbf{y})$</span> are respectively defined as:</p><p class="math-container">\[\mathrm{corr}(\mathbf{x}, \mathbf{y}) = \frac{\sum_i (x_{i} - \overline{x})(y_{i} - \overline{y})}{\sqrt{\sum_i (x_{i} - \overline{x})^2} \sqrt{\sum_i (y_{i} - \overline{y})^2}},\]</p><p class="math-container">\[\mathrm{cos}(\mathbf{x}, \mathbf{y}) = \frac{\mathbf{x} \cdot \mathbf{y}}{\| \mathbf{x} \| \| \mathbf{y} \|} = \frac{\sum_i x_{i} y_{i}}{\sqrt{\sum_i x_{i}^2} \sqrt{\sum_i y_{i}^2}},\]</p><p>where <span>$\overline{x} = \frac{1}{d} \sum^d_{i=1} x_i$</span> and <span>$\overline{y} = \frac{1}{d} \sum^d_{i=1} y_i$</span> denote mean values of the elements in a vector. Additionally, in a context of data mining, elements in <span>$\mathbf{x}$</span> and <span>$\mathbf{y}$</span> can be distributed on a different scale, so mean-centering of the vectors usually leads better results as shown by <a href="https://dl.acm.org/citation.cfm?id=372071">Sarwar et al.</a> Notice that cosine similarity between the mean-centered vectors, <span>$\hat{\mathbf{x}} = (x_1 - \overline{x}, x_2 - \overline{x}, \dots, x_n - \overline{x})$</span> and <span>$\hat{\mathbf{y}} = (y_1 - \overline{y}, y_2 - \overline{y}, \dots, y_n - \overline{y})$</span>, is mathematically equivalent to the Pearson correlation <span>$\mathrm{corr}(\mathbf{x}, \mathbf{y})$</span> as follows:</p><p class="math-container">\[\mathrm{cos}(\hat{\mathbf{x}}, \hat{\mathbf{y}}) = \frac{\sum_i (x_{i} - \overline{x})(y_{i} - \overline{y})}{\sqrt{\sum_i (x_{i} - \overline{x})^2} \sqrt{\sum_i (y_{i} - \overline{y})^2}} = \mathrm{corr}(\mathbf{x}, \mathbf{y}).\]</p><article class="docstring"><header><a class="docstring-binding" id="Recommendation.UserKNN" href="#Recommendation.UserKNN"><code>Recommendation.UserKNN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UserKNN(
    data::DataAccessor,
    k::Int,
    normalize::Bool=false
)</code></pre><p><a href="https://dl.acm.org/citation.cfm?id=312682">User-based CF using the Pearson correlation</a>. <code>k</code> represents number of neighbors, and <code>normalize</code> specifies if weighted sum of neighbors&#39; rating is normalized.</p><p>The technique gives a weight to a user-user pair by the following equation:</p><p class="math-container">\[s_{u, v} = \frac{ \sum_{i \in \mathcal{I}^+_{u \cap v}}  (r_{u, i} - \overline{r}_u) (r_{v, i} - \overline{r}_v)}
{ \sqrt{\sum_{i \in \mathcal{I}^+_{u \cap v}} (r_{u,i} - \overline{r}_u)^2} \sqrt{\sum_{i \in \mathcal{I}^+_{u \cap v}} (r_{v, i} - \overline{r}_v)^2} },\]</p><p>where <span>$\mathcal{I}^+_{u \cap v}$</span> is a set of items which were observed by both user <span>$u$</span> and <span>$v$</span>, and <span>$r_{u, i}$</span> indicates a <span>$(u, i)$</span> element in <span>$R$</span>. Plus, <span>$\overline{r}_u$</span> and <span>$\overline{r}_v$</span> are respectively mean values of <span>$r_{u, i}$</span> and <span>$r_{v, i}$</span> over <span>$i \in \mathcal{I}^+_{u \cap v}$</span>. By using the weights, user-based CF selects the top-<span>$k$</span> highest-weighted users (i.e., nearest neighbors) of a target user <span>$u$</span>, and predicts missing <span>$r_{u, i}$</span> for <span>$i \in \mathcal{I}^-_u$</span> as:</p><p class="math-container">\[r_{u, i} = \overline{r}_u + \frac{\sum^k_{t=1} \left(r_{\sigma(t), i} - \overline{r}_{\sigma(t)}\right) \cdot s_{u,\sigma(t)} }{ \sum^k_{t=1} s_{u,\sigma(t)} },\]</p><p>where <span>$\sigma(t)$</span> denotes the <span>$t$</span>-th nearest-neighborhood user. Ultimately, sorting items <span>$\mathcal{I}^-_u$</span> by the predicted values enables us to make recommendation to a user <span>$u$</span>.</p><p>It should be noted that user-based CF is highly inefficient because gradually increasing massive users and their dynamic tastes require us to frequently recompute the similarities for every pairs of users.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/takuti/Recommendation.jl/blob/551019ea415efd609edc137f72bf15f0cb436ce8/src/model/user_knn.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommendation.ItemKNN" href="#Recommendation.ItemKNN"><code>Recommendation.ItemKNN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ItemKNN(
    data::DataAccessor,
    k::Int
)</code></pre><p><a href="https://dl.acm.org/citation.cfm?id=963776">Item-based CF</a> that provides a way to model item-item concepts by utilizing the similarities of items in the CF paradigm. <code>k</code> represents number of neighbors.</p><p>Item properties are relatively stable compared to the users&#39; tastes, and the number of items is generally smaller than the number of users. Hence, while user-based CF successfully captures the similarities of users&#39; complex tastes, modeling item-item concepts could be much more promising in terms of both scalability and overall accuracy.</p><p>Item-based CF defines a similarity between an item <span>$i$</span> and <span>$j$</span> as:</p><p class="math-container">\[s_{i,j} = \frac{ \sum_{u \in \mathcal{U}_{i \cap j}}  (r_{u, i} - \overline{r}_i) (r_{u, j} - \overline{r}_j)}
{ \sqrt{\sum_{u \in \mathcal{U}_{i \cap j}} (r_{u,i} - \overline{r}_i)^2} \sqrt{\sum_{u \in \mathcal{U}_{i \cap j}} (r_{u, j} - \overline{r}_j)^2} },\]</p><p>where <span>$\mathcal{U}_{i \cap j}$</span> is a set of users that both of <span>$r_{u,i}$</span> and <span>$r_{u, j}$</span> are not missing, and <span>$\overline{r}_i, \overline{r}_j$</span> are mean values of <span>$i$</span>-th and <span>$j$</span>-th column in <span>$R$</span>. Similarly to the user-based algorithm, for the <span>$t$</span>-th nearest-neighborhood item <span>$\tau(t)$</span>, prediction can be done by top-<span>$k$</span> weighted sum of target user&#39;s feedbacks:</p><p class="math-container">\[r_{u,i} = \frac{\sum^k_{t=1} s_{i,\tau(t)} \cdot r_{u,\tau(t)} }{ \sum^k_{t=1} s_{i,\tau(t)} }.\]</p><p>In case that the number of items is smaller than users, item-based CF could be a more reasonable choice than the user-based approach.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/takuti/Recommendation.jl/blob/551019ea415efd609edc137f72bf15f0cb436ce8/src/model/item_knn.jl#L3-L27">source</a></section></article><h2 id="Singular-Value-Decomposition"><a class="docs-heading-anchor" href="#Singular-Value-Decomposition">Singular Value Decomposition</a><a id="Singular-Value-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Decomposition" title="Permalink"></a></h2><p>Along with the development of the <span>$k$</span>-NN techniques, researchers noticed that handling the original huge user-item matrices is computationally expensive. Moreover, <span>$k$</span>-NN-based recommendation leads overfitting to individual taste due to the sparsity of <span>$R$</span>. Thus, <a href="http://files.grouplens.org/papers/webKDD00.pdf">dimensionality reduction techniques were applied to recommendation</a> in order to capture more abstract preferences.</p><p>Singular value decomposition (SVD) is one of the most popular dimensionality reduction techniques which decomposes an <span>$m$</span>-by-<span>$n$</span> matrix <span>$A$</span> to <span>$U \in \mathbb{R}^{m \times m}$</span>, <span>$\Sigma \in \mathbb{R}^{m \times n}$</span> and <span>$V \in \mathbb{R}^{n \times n}$</span>:</p><p class="math-container">\[\mathrm{SVD}(A) = U \Sigma V^{\mathrm{T}} = \left[\mathbf{u}_1, \mathbf{u}_2, \cdots, \mathbf{u}_m\right] \mathrm{diag}\left(\sigma_1, \sigma_2, \dots, \sigma_{\min(m, n)}\right) \left[\mathbf{v}_1, \mathbf{v}_2, \cdots, \mathbf{v}_n\right]^{\mathrm{T}},\]</p><p>by letting <span>$\sigma_1 \geq \sigma_2 \geq \cdots \geq \sigma_{\min(m, n)} \geq 0$</span>. An orthogonal matrix <span>$U$</span> (<span>$V$</span>) is called left (right) singular vectors which represents characteristics of columns (rows) in <span>$R$</span>, and a diagonal matrix <span>$\Sigma$</span> holds singular values on the diagonal elements as weights of each singular vector.</p><p>The reason why SVD can be applied to dimensionality reduction is that the most lower singular values of real-world matrices are very close to zero. Hence, using only top-<span>$k$</span> singular values <span>$\Sigma_k \in \mathbb{R}^{k \times k}$</span> and corresponding singular vectors <span>$U_k \in \mathbb{R}^{m \times k}$</span>, <span>$V_k \in \mathbb{R}^{n \times k}$</span> is sufficient to make reasonable rank-<span>$k$</span> approximation of a matrix <span>$A$</span>. The following figure demonstrates how SVD decomposes a matrix into rank-<span>$k$</span> matrices.</p><p><img src="../assets/images/svd.png" alt="svd"/></p><p>On top of that, <span>$\mathrm{SVD}_k(A)$</span> is known as the best rank-<span>$k$</span> approximation of the matrix <span>$A$</span> in both the spectral and Frobenius norm. Note that the spectral norm of a matrix equals to its largest singular value.</p><article class="docstring"><header><a class="docstring-binding" id="Recommendation.SVD" href="#Recommendation.SVD"><code>Recommendation.SVD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SVD(
    data::DataAccessor,
    k::Int
)</code></pre><p>Recommendation based on SVD of a user-item matrix <span>$R \in \mathbb{R}^{|\mathcal{U}| \times |\mathcal{I}|}$</span>, which was originally studied by <a href="http://files.grouplens.org/papers/webKDD00.pdf">Sarwar et al.</a> Rank <span>$k$</span> is configured by <code>k</code>.</p><p>In a context of recommendation, <span>$U_k \in \mathbb{R}^{|\mathcal{U}| \times k}$</span>, <span>$V \in \mathbb{R}^{|\mathcal{I}| \times k}$</span> and <span>$\Sigma \in \mathbb{R}^{k \times k}$</span> are respectively seen as <span>$k$</span> user/item feature vectors and corresponding weights. The idea of low-rank approximation that discards lower singular values intuitively works as <em>compression</em> or <em>denoising</em> of the original matrix; that is, each element in a rank-<span>$k$</span> matrix <span>$A_k$</span> holds the best <em>compressed</em> (or <em>denoised</em>) value of the original element in <span>$A$</span>. Thus, <span>$R_k = \mathrm{SVD}_k(R)$</span>, the best rank-<span>$k$</span> approximation of <span>$R$</span>, captures as much as possible of underlying users&#39; preferences. Once <span>$R$</span> is decomposed into <span>$U, \Sigma$</span> and <span>$V$</span>, a <span>$(u, i)$</span> element of <span>$R_k$</span> calculated by <span>$\sum^k_{j=1} \sigma_j u_{u, j} v_{i, j}$</span> could be a prediction for the user-item pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/takuti/Recommendation.jl/blob/551019ea415efd609edc137f72bf15f0cb436ce8/src/model/svd.jl#L3-L12">source</a></section></article><p>SVD actually works well on user-item matrices, but the method poses some difficulties in practice. First, finding optimal <span>$k$</span> is not straightforward. Even though <span>$R_k$</span> is the best rank-<span>$k$</span> approximation of <span>$R$</span>, too small <span>$k$</span> obviously loses too much information of the original matrix, and it decreases the accuracy of recommendation. At the same time, too large <span>$k$</span> prevents taking advantage of dimensionality reduction. Hence, carefully choosing <span>$k$</span> by evaluation on a local environment is practically important.</p><p>Furthermore, the following points require us to take an extra effort to make SVD feasible for recommendation:</p><ul><li>We need to preliminarily fill missing values in <span>$R$</span> to launch SVD, and there are several options such as mean imputation and zero filling.</li><li>Although the original matrix <span>$R$</span> is a huge matrix in both rows and columns, SVD is a computationally expensive operation.</li><li>Explaining how the recommendation was generated is practically important, but it is hard for SVD-based recommendation unless mathematical background is explained.</li></ul><h2 id="Matrix-Factorization"><a class="docs-heading-anchor" href="#Matrix-Factorization">Matrix Factorization</a><a id="Matrix-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Factorization" title="Permalink"></a></h2><p>Even though dimensionality reduction is a promising approach to make effective recommendation, SVD is not feasible enough in terms of running time and missing value imputation. As a result, a new technique generally called matrix factorization (MF) was introduced by <a href="https://ieeexplore.ieee.org/document/5197422">Koren et al.</a></p><p>The initial MF technique was invented by <a href="http://sifter.org/~simon/journal/20061211.html">Funk</a> during the Netflix Prize, and the method is called <em>regularized SVD</em> because it can be seen as an extension of the conventional SVD-based recommendation. Regularized SVD and the other MF techniques achieved efficient approximation of the original SVD based on gradient descent optimization, and we do not need to care about missing values in <span>$R$</span> any more. The basic idea of MF is to factorize a user-item matrix <span>$R$</span> to a user factored matrix <span>$P \in \mathbb{R}^{|\mathcal{U}| \times k}$</span> and item factored matrix <span>$Q \in \mathbb{R}^{|\mathcal{I}| \times k}$</span> as shown below. Eventually, <span>$R$</span> is approximated by <span>$PQ^{\mathrm{T}}$</span>. Unlike SVD, singular values in <span>$\Sigma$</span> are embedded to the factored matrices, and orthogonality is lost. Thus, taking advantage of mathematically tractable properties of SVD is unfortunately impossible for MF.</p><p><img src="../assets/images/mf.png" alt="mf"/></p><article class="docstring"><header><a class="docstring-binding" id="Recommendation.MatrixFactorization" href="#Recommendation.MatrixFactorization"><code>Recommendation.MatrixFactorization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MatrixFactorization(
    data::DataAccessor,
    k::Int
)</code></pre><p>Recommendation based on matrix factorization (MF). Number of factors is configured by <code>k</code>.</p><p>MF solves the following minimization problem for a set of observed user-item interactions <span>$\mathcal{S} = \{(u, i) \in \mathcal{U} \times \mathcal{I}\}$</span>:</p><p class="math-container">\[\min_{P, Q} \sum_{(u, i) \in \mathcal{S}} \left( r_{u,i} - \mathbf{p}_u^{\mathrm{T}} \mathbf{q}_i \right)^2 + \lambda \ (\|\mathbf{p}_u\|^2 + \|\mathbf{q}_i\|^2),\]</p><p>where <span>$\mathbf{p}_u, \mathbf{q}_i \in \mathbb{R}^k$</span> are respectively a factorized user and item vector, and <span>$\lambda$</span> is a regularization parameter to avoid overfitting. An optimal solution will be found by stochastic gradient descent (SGD). Ultimately, we can predict missing values in <span>$R$</span> by just computing <span>$PQ^{\mathrm{T}}$</span>, and the prediction directly leads recommendation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/takuti/Recommendation.jl/blob/551019ea415efd609edc137f72bf15f0cb436ce8/src/model/matrix_factorization.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Recommendation.MF" href="#Recommendation.MF"><code>Recommendation.MF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MF(
    data::DataAccessor,
    k::Int
)</code></pre><p>Alias of <code>MatrixFactorization</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/takuti/Recommendation.jl/blob/551019ea415efd609edc137f72bf15f0cb436ce8/src/model/matrix_factorization.jl#L34-L41">source</a></section></article><p>MF is attractive in terms of not only efficiency but extensibility. In the above formulation, prediction for each user-item pair can be written by a simple vector product as <span>$r_{u,i} = \mathbf{p}_u^{\mathrm{T}} \mathbf{q}_i$</span>, and extension of the formula is also possible. That is, we can incorporate different features (e.g., biases and temporal factors) into the model as linear combinations. For example, let <span>$\mu$</span> be a global mean of all elements in <span>$R$</span>, and <span>$b_u, b_i$</span> be respectively a user and item bias term. Here, we assume that each observation can be represented as <span>$r_{u,i} = \mu + b_u + b_i + \mathbf{p}_u^{\mathrm{T}} \mathbf{q}_i$</span>. This formulation is known as <a href="https://ieeexplore.ieee.org/document/5197422">biased MF</a>, and it is possible to capture more information than the original MF even on the same set of events <span>$\mathcal{S}$</span>.</p><p>Additionally, options for loss functions are also abundant. To give an example, <a href="https://arxiv.org/abs/1109.2271">Chen et al.</a> showed various types of features and loss functions which can be incorporated into a MF scheme. An appropriate choice of their combinations is likely to lead surprisingly better accuracy compared to the classical MF.</p><p>It should be noted that the technique has many limitations behind great success of MF-based recommendation. Since extension of MF only allows us to append new features as linear combinations, representing more complex relationships between features is not straightforward. As a consequence, modern recommenders tend to use more complex models which are higher dimensional and hard to optimize such as <a href="https://dl.acm.org/citation.cfm?id=1864727">tensor factorization</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../baseline/">« Non-Personalized Baselines</a><a class="docs-footer-nextpage" href="../factorization_machines/">Factorization Machines »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 31 December 2021 18:05">Friday 31 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
